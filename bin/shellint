#!/usr/bin/env bash
#
# ╭──────────────────────────────────────────────────────────────╮
# │  shellint ⚡ Shell script linter & formatter                 │
# │  Part of the SilkCircuit dotfiles ecosystem                  │
# ╰──────────────────────────────────────────────────────────────╯
#
# Handles:
# 1. Linting with shellcheck
# 2. Formatting with shfmt
# 3. Auto-fixing shellcheck issues
#

set -eo pipefail

# ─────────────────────────────────────────────────────────────
# SilkCircuit Neon Palette (24-bit RGB)
# ─────────────────────────────────────────────────────────────
RESET="\033[0m"
BOLD="\033[1m"

# Core palette
SC_PURPLE='\033[38;2;225;53;255m'  # #e135ff - Electric Purple
SC_CYAN='\033[38;2;128;255;234m'   # #80ffea - Neon Cyan
SC_PINK='\033[38;2;255;121;198m'   # #ff79c6 - Hot Pink
SC_YELLOW='\033[38;2;241;250;140m' # #f1fa8c - Electric Yellow
SC_GREEN='\033[38;2;80;250;123m'   # #50fa7b - Success Green
SC_RED='\033[38;2;255;99;99m'      # #ff6363 - Error Red
SC_ORANGE='\033[38;2;255;180;100m' # #ffb464 - Warning Orange
SC_GRAY='\033[38;2;98;114;164m'    # #6272a4 - Muted Gray
SC_WHITE='\033[38;2;248;248;242m'  # #f8f8f2 - Pure White

# Global cache variables for git operations (bash 3.x compatible)
GIT_REPO_ROOT=""
SUBMODULE_PATHS=""
IS_GIT_REPO=0
SHELLCHECK_CONFIG=""

# ─────────────────────────────────────────────────────────────
# SilkCircuit Output Functions
# ─────────────────────────────────────────────────────────────
err() { echo -e "${SC_RED}${BOLD}✖ error:${RESET} $*"; }
warn() { echo -e "${SC_ORANGE}⚠ $*${RESET}"; }
info() { echo -e "${SC_PURPLE}▸ $*${RESET}"; }
dbg() { echo -e "${SC_GRAY}◦ $*${RESET}"; }
verb() { echo -e "${SC_CYAN}› $*${RESET}"; }
ok() { echo -e "${SC_GREEN}✓ $*${RESET}"; }
hi() { echo -e "${SC_PINK}★ $*${RESET}"; }
note() { echo -e "${SC_YELLOW}◆ $*${RESET}"; }

# Action messages with consistent formatting
checking() { echo -e "${SC_CYAN}⚡${RESET} checking ${BOLD}${SC_WHITE}$*${RESET}..."; }
fixing() { echo -e "${SC_PINK}⚙${RESET} fixing ${BOLD}${SC_WHITE}$*${RESET}..."; }
formatting() { echo -e "${SC_PURPLE}◈${RESET} formatting ${BOLD}${SC_WHITE}$*${RESET}..."; }

# Result patterns
no_issues() { echo -e "  ${SC_GREEN}✓${RESET} ${SC_GRAY}no issues in${RESET} ${SC_CYAN}$*${RESET}"; }
fixed() { echo -e "  ${SC_GREEN}✓${RESET} ${SC_PINK}fixed${RESET} ${SC_CYAN}$*${RESET}"; }
well_formatted() { echo -e "  ${SC_GREEN}✓${RESET} ${SC_GRAY}already formatted${RESET} ${SC_CYAN}$*${RESET}"; }
no_fixable() { echo -e "  ${SC_YELLOW}◆${RESET} ${SC_GRAY}no auto-fixes for${RESET} ${SC_CYAN}$*${RESET}"; }
nothing_to_fix() { echo -e "  ${SC_GREEN}✓${RESET} ${SC_GRAY}nothing to fix in${RESET} ${SC_CYAN}$*${RESET}"; }

# Initialize git cache - call once at startup
init_git_cache() {
  if git rev-parse --is-inside-work-tree &> /dev/null; then
    IS_GIT_REPO=1
    GIT_REPO_ROOT=$(git rev-parse --show-toplevel)
    SUBMODULE_PATHS=$(git config --file .gitmodules --get-regexp path 2> /dev/null | awk '{print $2}' || echo "")

    # Initialize shellcheck config
    local config_file="${GIT_REPO_ROOT}/.shellcheckrc"
    if [[ -f "${config_file}" ]]; then
      SHELLCHECK_CONFIG="--rcfile=${config_file}"
    fi
  else
    IS_GIT_REPO=0
  fi
}

# Dependency check
check_deps() {
  local missing=0
  for cmd in shellcheck shfmt patch; do
    if ! command -v "${cmd}" &> /dev/null; then
      echo -e "${SC_RED}✖${RESET} ${SC_WHITE}${cmd}${RESET} ${SC_GRAY}not found${RESET}"
      missing=1
    fi
  done

  if [[ ${missing} -eq 1 ]]; then
    echo ""
    echo -e "${SC_YELLOW}◆ Install missing dependencies:${RESET}"
    echo -e "  ${SC_CYAN}shellcheck${RESET} ${SC_GRAY}→${RESET} https://github.com/koalaman/shellcheck"
    echo -e "  ${SC_CYAN}shfmt${RESET}      ${SC_GRAY}→${RESET} https://github.com/mvdan/sh"
    echo -e "  ${SC_CYAN}patch${RESET}      ${SC_GRAY}→${RESET} brew install patch ${SC_GRAY}/${RESET} apt install patch"
    echo ""
    exit 1
  fi
}

# Print usage information
usage() {
  echo ""
  echo -e "${SC_PURPLE}${BOLD}  ╭────────────────────────────────────────╮${RESET}"
  echo -e "${SC_PURPLE}${BOLD}  │${RESET}  ${SC_CYAN}${BOLD}shellint${RESET} ${SC_GRAY}⚡${RESET} ${SC_WHITE}shell linter & formatter${RESET}  ${SC_PURPLE}${BOLD}│${RESET}"
  echo -e "${SC_PURPLE}${BOLD}  ╰────────────────────────────────────────╯${RESET}"
  echo ""
  echo -e "${SC_WHITE}${BOLD}USAGE${RESET}"
  echo -e "  ${SC_CYAN}shellint${RESET} ${SC_GRAY}[options]${RESET} ${SC_WHITE}[file(s)/directory]${RESET}"
  echo ""
  echo -e "${SC_WHITE}${BOLD}OPTIONS${RESET}"
  echo -e "  ${SC_CYAN}-c${RESET}, ${SC_CYAN}--check${RESET}         ${SC_GRAY}check files without modifying${RESET}"
  echo -e "  ${SC_CYAN}-f${RESET}, ${SC_CYAN}--fix${RESET}           ${SC_GRAY}auto-fix shellcheck issues${RESET}"
  echo -e "  ${SC_CYAN}-F${RESET}, ${SC_CYAN}--format${RESET}        ${SC_GRAY}format files with shfmt${RESET}"
  echo -e "  ${SC_CYAN}-a${RESET}, ${SC_CYAN}--all${RESET}           ${SC_GRAY}run all (format + fix + check)${RESET}"
  echo -e "  ${SC_CYAN}-r${RESET}, ${SC_CYAN}--recursive${RESET}     ${SC_GRAY}recursively process directories${RESET}"
  echo -e "  ${SC_CYAN}-q${RESET}, ${SC_CYAN}--quiet${RESET}         ${SC_GRAY}minimal output${RESET}"
  echo -e "  ${SC_CYAN}-v${RESET}, ${SC_CYAN}--verbose${RESET}       ${SC_GRAY}verbose output${RESET}"
  echo -e "  ${SC_CYAN}-e${RESET}, ${SC_CYAN}--exclude${RESET}=${SC_YELLOW}LIST${RESET}  ${SC_GRAY}exclude shellcheck codes${RESET}"
  echo -e "  ${SC_CYAN}-s${RESET}, ${SC_CYAN}--submodules${RESET}    ${SC_GRAY}include git submodules${RESET}"
  echo -e "  ${SC_CYAN}-h${RESET}, ${SC_CYAN}--help${RESET}          ${SC_GRAY}display this help${RESET}"
  echo ""
  echo -e "${SC_WHITE}${BOLD}EXAMPLES${RESET}"
  echo -e "  ${SC_PURPLE}▸${RESET} shellint --check sh/           ${SC_GRAY}# check all scripts in sh/${RESET}"
  echo -e "  ${SC_PURPLE}▸${RESET} shellint --fix script.sh       ${SC_GRAY}# auto-fix a single file${RESET}"
  echo -e "  ${SC_PURPLE}▸${RESET} shellint --format --recursive  ${SC_GRAY}# format everything${RESET}"
  echo -e "  ${SC_PURPLE}▸${RESET} shellint --all sh/             ${SC_GRAY}# full cleanup${RESET}"
  echo -e "  ${SC_PURPLE}▸${RESET} shellint -e SC2086 --fix       ${SC_GRAY}# fix, skip specific code${RESET}"
  echo ""
}

# Fast check if path is in a git submodule using cached data
is_in_submodule() {
  local path="$1"

  [[ ${IS_GIT_REPO} -eq 0 ]] && return 1
  [[ -z "${SUBMODULE_PATHS}" ]] && return 1

  # Check if path is in any submodule using cached data
  while IFS= read -r submodule; do
    [[ -n "${submodule}" && "${path}" == "${submodule}"* ]] && return 0
  done <<< "${SUBMODULE_PATHS}"

  return 1
}

# Check if a given path is a submodule directory path using cached data
is_target_a_submodule_dir() {
  local dir_path="$1"

  [[ ${IS_GIT_REPO} -eq 0 ]] && return 1
  [[ -z "${SUBMODULE_PATHS}" ]] && return 1

  local normalized_dir_path="${dir_path%/}"

  while IFS= read -r submodule_path_from_config; do
    if [[ -n "${submodule_path_from_config}" ]]; then
      local normalized_submodule_path="${submodule_path_from_config%/}"
      [[ "${normalized_dir_path}" == "${normalized_submodule_path}" ]] && return 0
    fi
  done <<< "${SUBMODULE_PATHS}"

  return 1
}

# Find shell scripts in a directory
find_scripts() {
  local dir="$1"
  local recursive="$2"
  local include_submodules="$3"

  if [[ "${recursive}" -eq 1 ]]; then
    if [[ ${IS_GIT_REPO} -eq 1 ]]; then
      if [[ "${include_submodules}" -eq 1 ]]; then
        git ls-files --recurse-submodules -- "${dir}"
      else
        git ls-files -- "${dir}"
      fi
    else
      find "${dir}" -type f -not -path "*/\\.*" -print 2> /dev/null || true
    fi
  else
    find "${dir}" -maxdepth 1 -type f -not -path "*/\\.*" -print 2> /dev/null || true
  fi
}

# Simplified shell script detection
is_shell_script() {
  local file="$1"

  # Quick file type check using file command
  local file_type
  file_type=$(file -b "${file}" 2> /dev/null || echo "")
  [[ "${file_type}" =~ (shell script|sh script|bash script|zsh script|Bourne-Again shell|POSIX shell) ]]
}

# Simplified script identification
should_process_file() {
  local file="$1"
  local file_basename
  file_basename=$(basename "${file}")
  local file_path="${file#./}" # Remove leading ./

  # Quick pattern matching - order by likelihood
  case "${file_basename}" in
    *.sh | *.bash | *.zsh) return 0 ;;
    *bashrc* | *zshrc*) return 0 ;;
    zshenv | zlogin | zlogout | zprofile) return 0 ;;
    *) ;; # Continue to other checks
  esac

  # bin/* files need content check
  if [[ "${file_path}" == bin/* && "${file_path#bin/}" != */* ]]; then
    is_shell_script "${file}"
    return $?
  fi

  # Fallback to shebang check for other files
  is_shell_script "${file}"
}

# Run shellcheck on a file and report issues - optimized to avoid temp files
run_shellcheck() {
  local file="$1"
  local exclude="$2"
  local quiet="$3"

  local exclude_arg=""
  [[ -n "${exclude}" ]] && exclude_arg="--exclude=${exclude}"

  [[ "${quiet}" -eq 0 ]] && checking "${file}"

  # Run shellcheck directly on the file using cached config
  local issues
  issues=$(shellcheck "${SHELLCHECK_CONFIG}" "${exclude_arg}" "${file}" 2>&1) || true

  # Filter out the openBinaryFile error message if present
  issues=$(echo "${issues}" | grep -v "openBinaryFile: does not exist" || true)

  if [[ -n "${issues}" ]]; then
    if [[ "${quiet}" -eq 0 ]]; then
      echo -e "  ${SC_RED}✖${RESET} ${SC_ORANGE}issues in${RESET} ${SC_CYAN}${file}${RESET}"
      echo "${issues}" | while IFS= read -r line; do
        # Colorize based on line content
        if [[ "${line}" =~ ^In\ .* ]]; then
          echo -e "    ${SC_GRAY}${line}${RESET}"
        elif [[ "${line}" =~ ^[[:space:]]*\^-- ]]; then
          echo -e "    ${SC_YELLOW}${line}${RESET}"
        elif [[ "${line}" =~ SC[0-9]+ ]]; then
          echo -e "    ${SC_ORANGE}${line}${RESET}"
        else
          echo -e "    ${SC_WHITE}${line}${RESET}"
        fi
      done
      echo
    fi
    return 1
  else
    [[ "${quiet}" -eq 0 ]] && no_issues "${file}"
    return 0
  fi
}

# Fix shellcheck issues using diff format - optimized
fix_shellcheck() {
  local file="$1"
  local exclude="$2"
  local quiet="$3"
  local verbose="$4"

  local exclude_arg=""
  [[ -n "${exclude}" ]] && exclude_arg="--exclude=${exclude}"

  # Run shellcheck directly with cached config
  local diff
  diff=$(shellcheck -f diff "${SHELLCHECK_CONFIG}" "${exclude_arg}" "${file}" 2> /dev/null || true)

  # Silent if no fixes needed
  if [[ -z "${diff}" || "${diff}" != "--- a/"* ]]; then
    return 0
  fi

  if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
    echo -e "${SC_PINK}⚙${RESET} ${SC_WHITE}${file}${RESET}"
    echo "${diff}" | while IFS= read -r line; do
      case "${line}" in
        "+"*) echo -e "  ${SC_GREEN}${line}${RESET}" ;;
        "-"*) echo -e "  ${SC_RED}${line}${RESET}" ;;
        "@"*) echo -e "  ${SC_PURPLE}${line}${RESET}" ;;
        *) echo -e "  ${SC_GRAY}${line}${RESET}" ;;
      esac
    done
  fi

  # Create a temporary directory for patching
  local tmp_dir
  tmp_dir=$(mktemp -d)
  local file_name
  file_name=$(basename "${file}")

  # Setup patch environment
  mkdir -p "${tmp_dir}/a" "${tmp_dir}/b"
  cp "${file}" "${tmp_dir}/a/" "${tmp_dir}/b/"

  # Modify and apply the diff
  local modified_diff
  modified_diff=$(echo "${diff}" | sed "s|--- a/.*|--- a/${file_name}|" | sed "s|+++ b/.*|+++ b/${file_name}|")

  if echo "${modified_diff}" | (cd "${tmp_dir}" && patch -p1 -s); then
    cp "${tmp_dir}/b/${file_name}" "${file}"
    [[ "${quiet}" -eq 0 ]] && echo -e "${SC_PINK}⚙${RESET} ${SC_GREEN}fixed${RESET} ${SC_CYAN}${file}${RESET}"
  else
    [[ "${quiet}" -eq 0 ]] && echo -e "${SC_YELLOW}◆${RESET} ${SC_GRAY}patch failed${RESET} ${SC_CYAN}${file}${RESET}"
  fi

  rm -rf "${tmp_dir}"
  return 0
}

# Format script with shfmt
format_script() {
  local file="$1"
  local quiet="$2"
  local verbose="$3"

  # Convert to absolute path if not already
  local abs_file
  abs_file=$(readlink -f "${file}" 2> /dev/null || realpath "${file}" 2> /dev/null || echo "${file}")

  # Check if formatting is needed first, relying on .editorconfig
  local needs_formatting
  needs_formatting=$(shfmt -l "${abs_file}" 2> /dev/null || true)

  if [[ -n "${needs_formatting}" ]]; then
    if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
      local diff
      diff=$(shfmt -d "${abs_file}" 2> /dev/null || true)
      echo -e "${SC_PURPLE}◈${RESET} ${SC_WHITE}${file}${RESET}"

      echo "${diff}" | while IFS= read -r line; do
        case "${line}" in
          "+"*) echo -e "  ${SC_GREEN}${line}${RESET}" ;;
          "-"*) echo -e "  ${SC_RED}${line}${RESET}" ;;
          "@"*) echo -e "  ${SC_PURPLE}${line}${RESET}" ;;
          *) echo -e "  ${SC_GRAY}${line}${RESET}" ;;
        esac
      done
    fi

    # Apply formatting, relying on .editorconfig
    shfmt -w "${abs_file}" 2> /dev/null

    [[ "${quiet}" -eq 0 ]] && echo -e "${SC_PURPLE}◈${RESET} ${SC_PINK}formatted${RESET} ${SC_CYAN}${file}${RESET}"
  fi
  # Silent if already formatted
}

# Process a single file - simplified and optimized
process_file() {
  local file="$1"
  local check="$2"
  local fix="$3"
  local format="$4"
  local exclude="$5"
  local quiet="$6"
  local verbose="$7"
  local include_submodules="$8"

  # Skip submodule handling if we're not including them
  if [[ "${include_submodules}" -eq 0 ]]; then
    is_target_a_submodule_dir "${file}"
    local is_submodule_dir=$?
    is_in_submodule "${file}"
    local in_submodule=$?
    if [[ "${is_submodule_dir}" -eq 0 || "${in_submodule}" -eq 0 ]]; then
      [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && note "skipping submodule: ${file}"
      return 0
    fi
  fi

  # Handle directories
  if [[ -d "${file}" ]]; then
    [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && note "skipping directory: ${file}"
    return 0
  fi

  # Check if file exists and is regular
  if [[ ! -f "${file}" ]]; then
    if [[ ! -e "${file}" ]]; then
      [[ "${quiet}" -eq 0 ]] && err "file not found: ${file}"
      return 1
    else
      [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && note "skipping non-regular file: ${file}"
      return 0
    fi
  fi

  # Check if we should process this file
  should_process_file "${file}"
  local should_process=$?
  if [[ "${should_process}" -ne 0 ]]; then
    [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && note "skipping non-shell file: ${file}"
    return 0
  fi

  local status=0

  # Process the file in order: format, fix, check
  [[ "${format}" -eq 1 ]] && format_script "${file}" "${quiet}" "${verbose}"
  [[ "${fix}" -eq 1 ]] && fix_shellcheck "${file}" "${exclude}" "${quiet}" "${verbose}"

  if [[ "${check}" -eq 1 ]]; then
    run_shellcheck "${file}" "${exclude}" "${quiet}"
    local shellcheck_result=$?
    if [[ "${shellcheck_result}" -ne 0 ]]; then
      status=1
    fi
  fi

  return "${status}"
}

# Print summary at the end
print_summary() {
  local file_count="$1"
  local exit_code="$2"
  local verbose="$3"
  local processed=("${@:4}")

  echo ""
  echo -e "${SC_PURPLE}─────────────────────────────────────────${RESET}"

  if [[ "${verbose}" -eq 1 ]]; then
    echo -e "${SC_GRAY}files processed:${RESET}"
    for file in "${processed[@]}"; do
      echo -e "  ${SC_CYAN}›${RESET} ${SC_WHITE}${file}${RESET}"
    done
    echo ""
  fi

  if [[ "${exit_code}" -eq 0 ]]; then
    echo -e "${SC_GREEN}${BOLD}✓ All checks passed!${RESET} ${SC_GRAY}(${file_count} files)${RESET}"
  else
    echo -e "${SC_ORANGE}${BOLD}⚠ Issues found${RESET} ${SC_GRAY}(${file_count} files checked)${RESET}"
    echo -e "${SC_YELLOW}  run ${SC_CYAN}--fix${RESET}${SC_YELLOW} to auto-fix what's possible${RESET}"
  fi
  echo ""
}

# Main function
main() {
  check_deps
  init_git_cache # Initialize git operations cache

  local check=0
  local fix=0
  local format=0
  local recursive=0
  local quiet=0
  local verbose=0
  local exclude=""
  local include_submodules=0
  local exit_code=0
  local targets=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --check)
        check=1
        shift
        ;;
      -f | --fix)
        fix=1
        shift
        ;;
      -F | --format)
        format=1
        shift
        ;;
      -a | --all)
        check=1
        fix=1
        format=1
        shift
        ;;
      -r | --recursive)
        recursive=1
        shift
        ;;
      -q | --quiet)
        quiet=1
        shift
        ;;
      -v | --verbose)
        verbose=1
        shift
        ;;
      -s | --submodules)
        include_submodules=1
        shift
        ;;
      -e=* | --exclude=*)
        exclude="${1#*=}"
        shift
        ;;
      -e | --exclude)
        exclude="$2"
        shift 2
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      -*)
        err "unknown option: $1"
        usage
        exit 1
        ;;
      *)
        targets+=("$1")
        shift
        ;;
    esac
  done

  # Default to check mode if no action flags specified
  if [[ "${check}" -eq 0 && "${fix}" -eq 0 && "${format}" -eq 0 ]]; then
    check=1
  fi

  # If no targets specified, use current directory
  [[ ${#targets[@]} -eq 0 ]] && targets=(".")

  # Debug: Show targets
  if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
    verb "processing targets:"
    printf '  - %s\n' "${targets[@]}"
  fi

  # Process all targets
  local file_count=0
  local processed=()

  # Don't fail fast, process all files
  set +e

  for target in "${targets[@]}"; do
    [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && verb "processing target: ${target}"

    if [[ -d "${target}" ]]; then
      # Process directory
      local scripts
      [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && verb "finding scripts in directory: ${target} (recursive=${recursive})"

      scripts=$(find_scripts "${target}" "${recursive}" "${include_submodules}")

      if [[ -z "${scripts}" ]]; then
        [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && note "no scripts found in ${target}"
        continue
      fi

      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        verb "found scripts:"
        while IFS= read -r script; do
          echo "  - ${script}"
        done <<< "${scripts}"
      fi

      # Process each script found
      while IFS= read -r script; do
        if [[ -n "${script}" ]]; then
          [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && verb "processing script: ${script}"

          process_file "${script}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}" "${include_submodules}"
          local process_result=$?
          if [[ "${process_result}" -ne 0 ]]; then
            exit_code=1
            [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && err "failed to process ${script}, continuing with next file"
          fi
          processed+=("${script}")
          ((file_count++))
        fi
      done < <(echo "${scripts}")
    elif [[ -f "${target}" ]]; then
      # Process single file
      [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && verb "processing file: ${target}"

      process_file "${target}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}" "${include_submodules}"
      local process_result=$?
      if [[ "${process_result}" -ne 0 ]]; then
        exit_code=1
        [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]] && err "failed to process ${target}, continuing with next file"
      fi
      processed+=("${target}")
      ((file_count++))
    else
      err "target not found: ${target}"
      exit_code=1
    fi
  done

  # Restore error handling
  set -e

  # Summary
  if [[ "${quiet}" -eq 0 && ${#processed[@]} -gt 0 ]]; then
    print_summary "${file_count}" "${exit_code}" "${verbose}" "${processed[@]}"
  fi

  return "${exit_code}"
}

main "$@"
