#!/usr/bin/env bash
#
# shellint - Shell script linter and formatter
# A powerful tool for checking and fixing shell scripts in your dotfiles
#
# Handles:
# 1. Linting with shellcheck
# 2. Formatting with shfmt
# 3. Auto-fixing shellcheck issues
#

set -eo pipefail

# ANSI color codes for beautiful output ðŸ’…
RESET="\033[0m"
BOLD="\033[1m"
RED="\033[38;5;197m"     # Hot pink for errors
ORANGE="\033[38;5;203m"  # For warnings
MAGENTA="\033[38;5;171m" # For info
PURPLE="\033[38;5;141m"  # For debug
BLUE="\033[38;5;75m"     # For verbose
CYAN="\033[38;5;123m"    # For success
PINK="\033[38;5;219m"    # For highlights
YELLOW="\033[38;5;227m"  # For caution

# Color utility functions - short and sweet ðŸ’…
err() { echo -e "${RED}${BOLD}Error:${RESET} $*"; }
warn() { echo -e "${ORANGE}$*${RESET}"; }
info() { echo -e "${MAGENTA}$*${RESET}"; }
dbg() { echo -e "${PURPLE}$*${RESET}"; }
verb() { echo -e "${BLUE}$*${RESET}"; }
ok() { echo -e "${CYAN}$*${RESET}"; }
hi() { echo -e "${PINK}$*${RESET}"; }
note() { echo -e "${YELLOW}$*${RESET}"; }
b() { echo -e "${BOLD}$*${RESET}"; }

# Action messages with consistent formatting
checking() { info "Checking ${BOLD}$*${RESET}..."; }
fixing() { hi "Fixing ${BOLD}$*${RESET}..."; }
formatting() { info "Formatting ${BOLD}$*${RESET}..."; }

# Result patterns
no_issues() { ok "âœ“ No issues in $*"; }
fixed() { ok "âœ“ Fixed issues in $*"; }
well_formatted() { ok "âœ“ $* already properly formatted"; }
no_fixable() { note "No auto-fixable issues in $*"; }
nothing_to_fix() { ok "âœ“ No issues to fix in $*"; }

# Dependency check
check_deps() {
  local missing=0
  for cmd in shellcheck shfmt patch; do
    if ! command -v "${cmd}" &> /dev/null; then
      err "${cmd} is not installed"
      missing=1
    fi
  done

  if [[ ${missing} -eq 1 ]]; then
    echo
    note "Install missing dependencies:"
    echo -e "  ${CYAN}â€¢ shellcheck:${RESET} https://github.com/koalaman/shellcheck#installing"
    echo -e "  ${CYAN}â€¢ shfmt:${RESET} https://github.com/mvdan/sh#shfmt"
    echo -e "  ${CYAN}â€¢ patch:${RESET} available in most package managers (apt, brew, etc.)"
    exit 1
  fi
}

# Print usage information
usage() {
  echo -e "${BOLD}${PURPLE}shellint${RESET} - Shell script linter and formatter ðŸ’–\n"
  echo -e "${BOLD}Usage:${RESET}"
  echo -e "  shellint [options] [file(s)/directory]\n"
  echo -e "${BOLD}Options:${RESET}"
  echo -e "  -c, --check         Check files without modifying them"
  echo -e "  -f, --fix           Auto-fix shellcheck issues when possible"
  echo -e "  -F, --format        Format files with shfmt"
  echo -e "  -a, --all           Run all checks and fixes (format + fix)"
  echo -e "  -r, --recursive     Recursively process directories"
  echo -e "  -q, --quiet         Minimal output"
  echo -e "  -v, --verbose       Verbose output"
  echo -e "  -e, --exclude=LIST  Exclude shellcheck codes (comma-separated)"
  echo -e "  -s, --submodules    Include git submodules (excluded by default)"
  echo -e "  -h, --help          Display this help message\n"
  echo -e "${BOLD}Examples:${RESET}"
  echo -e "  shellint --check sh/           # Check all .sh files in sh/ directory"
  echo -e "  shellint --fix sh/android.sh   # Fix shellcheck issues in android.sh"
  echo -e "  shellint --format --recursive  # Format all shell files recursively"
  echo -e "  shellint --all sh/             # Format and fix all scripts in sh/"
  echo -e "  shellint -e SC2086,SC2046 --fix # Fix issues excluding certain codes\n"
}

# Check if path is in a git submodule
is_in_submodule() {
  local path="$1"

  # Skip check if we're not in a git repo
  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    return 1
  fi

  # Get the list of submodules
  local submodules
  submodules=$(git config --file .gitmodules --get-regexp path 2> /dev/null | awk '{print $2}' || echo "")

  if [[ -z "${submodules}" ]]; then
    return 1
  fi

  # Check if path is in any submodule
  while IFS= read -r submodule; do
    if [[ -n "${submodule}" && "${path}" == "${submodule}"* ]]; then
      return 0
    fi
  done <<< "${submodules}"

  return 1
}

# Find shell scripts in a directory
find_scripts() {
  local dir="$1"
  local recursive="$2"
  local include_submodules="$3"

  # Use printf to ensure one item per line, avoid issues with different find implementations
  if [[ "${recursive}" -eq 1 ]]; then
    # Try to use git ls-files for better handling of submodules if we're in a git repo
    if git rev-parse --is-inside-work-tree &> /dev/null; then
      if [[ "${include_submodules}" -eq 1 ]]; then
        # Find all files, let process_file filter
        git ls-files --recurse-submodules -- "${dir}"
      else
        # Find all files, let process_file filter
        git ls-files -- "${dir}"
      fi
    else
      # Find all files, let process_file filter
      find "${dir}" -type f -not -path "*/\\.*" -print 2> /dev/null || true
    fi
  else
    # Find all files, let process_file filter
    find "${dir}" -maxdepth 1 -type f -not -path "*/\\.*" -print 2> /dev/null || true
  fi
}

# Check if file is a shell script based on content (for files without extensions)
is_shell_script() {
  local file="$1"

  # Check shebang
  head -n1 "${file}" | grep -q '^#!.*\(sh\|bash\|zsh\)'
}

# Get shellcheck configuration
get_shellcheck_config() {
  local project_root
  project_root=$(git rev-parse --show-toplevel 2> /dev/null || pwd)

  local config_file="${project_root}/.shellcheckrc"
  local config_arg=""

  if [[ -f "${config_file}" ]]; then
    config_arg="--rc=${config_file}"
  fi

  echo "${config_arg}"
}

# Run shellcheck on a file and report issues
run_shellcheck() {
  local file="$1"
  local exclude="$2"
  local quiet="$3"

  local exclude_arg=""
  if [[ -n "${exclude}" ]]; then
    exclude_arg="--exclude=${exclude}"
  fi

  if [[ "${quiet}" -eq 0 ]]; then
    checking "${file}"
  fi

  # Get config
  local config_arg
  config_arg=$(get_shellcheck_config)

  # Create a temporary copy of the file
  local tmp_file
  tmp_file=$(mktemp)
  cat "${file}" > "${tmp_file}" || {
    err "Failed to create temporary file"
    return 1
  }

  # Run shellcheck with project config
  local issues
  issues=$(shellcheck "${config_arg}" "${exclude_arg}" "${tmp_file}" 2>&1) || true

  # Clean up temp file
  rm -f "${tmp_file}"

  # Filter out the openBinaryFile error message if present
  issues=$(echo "${issues}" | grep -v "openBinaryFile: does not exist")

  if [[ -n "${issues}" ]]; then
    if [[ "${quiet}" -eq 0 ]]; then
      warn "Issues found in ${file}:"
      echo "${issues}"
      echo
    fi
    return 1
  else
    if [[ "${quiet}" -eq 0 ]]; then
      no_issues "${file}"
    fi
    return 0
  fi
}

# Fix shellcheck issues using diff format
fix_shellcheck() {
  local file="$1"
  local exclude="$2"
  local quiet="$3"
  local verbose="$4"

  local exclude_arg=""
  if [[ -n "${exclude}" ]]; then
    exclude_arg="--exclude=${exclude}"
  fi

  if [[ "${quiet}" -eq 0 ]]; then
    fixing "${file}"
  fi

  # Get config
  local config_arg
  config_arg=$(get_shellcheck_config)

  # Create a temporary copy of the file
  local tmp_file
  tmp_file=$(mktemp)
  cat "${file}" > "${tmp_file}" || {
    err "Failed to create temporary file"
    return 1
  }

  # Run shellcheck with project config
  local diff
  diff=$(shellcheck -f diff "${config_arg}" "${exclude_arg}" "${tmp_file}" 2> /dev/null)

  # Clean up temp file
  rm -f "${tmp_file}"

  if [[ -n "${diff}" && "${diff}" != "--- a/"* ]]; then
    #  The diff output doesn't look like a proper patch
    if [[ "${quiet}" -eq 0 ]]; then
      no_fixable "${file}"
    fi
    return 0
  fi

  if [[ -n "${diff}" ]]; then
    if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
      verb "Applying fixes to ${file}:"
      echo "${diff}"
    fi

    # Create a temporary directory for patching
    local tmp_dir
    tmp_dir=$(mktemp -d)

    # Create subdirectory structure
    mkdir -p "${tmp_dir}/a" "${tmp_dir}/b"

    # Copy the file to both directories
    cp "${file}" "${tmp_dir}/a/"
    cp "${file}" "${tmp_dir}/b/"

    # Modify the diff to use our temporary paths
    local file_name
    file_name=$(basename "${file}")
    local modified_diff
    modified_diff=$(echo "${diff}" | sed "s|--- a/.*|--- a/${file_name}|" | sed "s|+++ b/.*|+++ b/${file_name}|")

    # Apply the diff in the temporary directory
    if ! echo "${modified_diff}" | (cd "${tmp_dir}" && patch -p1 -s); then
      if [[ "${quiet}" -eq 0 ]]; then
        warn "Failed to apply patch to ${file}. Leaving original untouched."
      fi
      rm -rf "${tmp_dir}"
      # Optionally, return a specific error code or set a flag
      # For now, we'll let it proceed to 'nothing_to_fix' or 'fixed' logic,
      # but the file won't have been changed if patch failed.
      # A more robust solution might return 1 here.
    else
      # Copy the patched file back only if patch succeeded
      cp "${tmp_dir}/b/${file_name}" "${file}"

      if [[ "${quiet}" -eq 0 ]]; then
        fixed "${file}"
      fi
    fi

    # Clean up
    rm -rf "${tmp_dir}"
    return 0 # Assuming success if patch applied or no diff
  else
    if [[ "${quiet}" -eq 0 ]]; then
      nothing_to_fix "${file}"
    fi
    return 0
  fi
}

# Format script with shfmt
format_script() {
  local file="$1"
  local quiet="$2"
  local verbose="$3"

  if [[ "${quiet}" -eq 0 ]]; then
    formatting "${file}"
  fi

  # Convert to absolute path if not already
  local abs_file
  abs_file=$(readlink -f "${file}" 2> /dev/null || realpath "${file}" 2> /dev/null || echo "${file}")

  # Check if formatting is needed first, relying on .editorconfig
  local needs_formatting
  needs_formatting=$(shfmt -l "${abs_file}" 2> /dev/null)

  if [[ -n "${needs_formatting}" ]]; then
    if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
      local diff
      # Get diff, relying on .editorconfig
      diff=$(shfmt -d "${abs_file}" 2> /dev/null)
      verb "Formatting changes for ${file}:"
      echo "${diff}"
    fi

    # Apply formatting, relying on .editorconfig
    shfmt -w "${abs_file}" 2> /dev/null

    if [[ "${quiet}" -eq 0 ]]; then
      ok "âœ“ Formatted ${file}"
    fi
  else
    if [[ "${quiet}" -eq 0 ]]; then
      well_formatted "${file}"
    fi
  fi
}

# Process a single file
process_file() {
  local file="$1"
  local check="$2"
  local fix="$3"
  local format="$4"
  local exclude="$5"
  local quiet="$6"
  local verbose="$7"
  local include_submodules="$8"

  # Skip non-existent files
  if [[ ! -f "${file}" ]]; then
    if [[ "${quiet}" -eq 0 ]]; then
      err "File not found: ${file}"
    fi
    return 1
  fi

  # Skip submodules if needed
  if [[ "${include_submodules}" -eq 0 ]]; then
    # Fix for SC2310: Call the function separately from the if condition
    is_in_submodule "${file}"
    local in_submodule=$?
    if [[ "${in_submodule}" -eq 0 ]]; then
      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        note "Skipping file in submodule: ${file}"
      fi
      return 0
    fi
  fi

  # Check if it's a shell script based on extension
  if [[ ! "${file}" =~ \.(sh|bash|zsh)$ ]]; then
    # For files without extension, check content
    is_shell_script "${file}"
    local is_shell=$?
    if [[ "${is_shell}" -ne 0 ]]; then
      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        note "Skipping non-shell file: ${file}"
      fi
      return 0
    fi
  fi

  local status=0

  # Format file if needed
  if [[ "${format}" -eq 1 ]]; then
    format_script "${file}" "${quiet}" "${verbose}"
  fi

  # Fix shellcheck issues
  if [[ "${fix}" -eq 1 ]]; then
    fix_shellcheck "${file}" "${exclude}" "${quiet}" "${verbose}"
  fi

  # Check for issues
  if [[ "${check}" -eq 1 ]]; then
    # Call run_shellcheck separately from the condition to avoid SC2310
    run_shellcheck "${file}" "${exclude}" "${quiet}"
    local shellcheck_result=$?
    if [[ "${shellcheck_result}" -ne 0 ]]; then
      status=1
    fi
  fi

  return "${status}"
}

# Print summary at the end
print_summary() {
  local file_count="$1"
  local exit_code="$2"
  local verbose="$3"
  local processed=("${@:4}")

  echo
  b "${CYAN}Summary:${RESET}"
  info "Processed ${BOLD}${file_count}${RESET}${MAGENTA} files${RESET}"

  if [[ "${verbose}" -eq 1 ]]; then
    verb "Files processed:"
    for file in "${processed[@]}"; do
      echo -e "  - ${file}"
    done
  fi

  if [[ "${exit_code}" -eq 0 ]]; then
    b "${CYAN}All checks passed! ðŸ’…${RESET}"
  else
    b "${ORANGE}Some checks failed. Review the output above.${RESET}"
  fi
}

# Main function
main() {
  check_deps

  local check=1 # Default to check mode
  local fix=0
  local format=0
  local recursive=0
  local quiet=0
  local verbose=0
  local exclude=""
  local include_submodules=0
  local exit_code=0
  local targets=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --check)
        check=1
        shift
        ;;
      -f | --fix)
        fix=1
        shift
        ;;
      -F | --format)
        format=1
        shift
        ;;
      -a | --all)
        check=1
        fix=1
        format=1
        shift
        ;;
      -r | --recursive)
        recursive=1
        shift
        ;;
      -q | --quiet)
        quiet=1
        shift
        ;;
      -v | --verbose)
        verbose=1
        shift
        ;;
      -s | --submodules)
        include_submodules=1
        shift
        ;;
      -e=* | --exclude=*)
        exclude="${1#*=}"
        shift
        ;;
      -e | --exclude)
        exclude="$2"
        shift 2
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      -*)
        err "Unknown option: $1"
        usage
        exit 1
        ;;
      *)
        targets+=("$1")
        shift
        ;;
    esac
  done

  # If no targets specified, use current directory
  if [[ ${#targets[@]} -eq 0 ]]; then
    targets=(".")
  fi

  # Debug: Show targets
  if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
    verb "Processing targets:"
    for target in "${targets[@]}"; do
      echo -e "  - ${target}"
    done
  fi

  # Process all targets
  local file_count=0
  local processed=()

  # Don't fail fast, process all files
  set +e

  for target in "${targets[@]}"; do
    if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
      verb "Processing target: ${target}"
    fi

    if [[ -d "${target}" ]]; then
      # Process directory
      local scripts
      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        verb "Finding scripts in directory: ${target} (recursive=${recursive})"
      fi

      scripts=$(find_scripts "${target}" "${recursive}" "${include_submodules}")

      if [[ -z "${scripts}" ]]; then
        if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
          note "No scripts found in ${target}"
        fi
        continue
      fi

      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        verb "Found scripts:"
        while IFS= read -r script; do
          echo "  - ${script}"
        done <<< "${scripts}"
      fi

      # Process each script found
      while IFS= read -r script; do
        if [[ -n "${script}" ]]; then
          if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
            verb "Processing script: ${script}"
          fi

          # Call process_file separately from the condition to avoid SC2310
          process_file "${script}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}" "${include_submodules}"
          local process_result=$?
          if [[ "${process_result}" -ne 0 ]]; then
            exit_code=1
            if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
              err "Failed to process ${script}, continuing with next file"
            fi
          fi
          processed+=("${script}")
          ((file_count++))
        fi
      done < <(echo "${scripts}")
    elif [[ -f "${target}" ]]; then
      # Process single file
      if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
        verb "Processing file: ${target}"
      fi

      # Call process_file separately from the condition to avoid SC2310
      process_file "${target}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}" "${include_submodules}"
      local process_result=$?
      if [[ "${process_result}" -ne 0 ]]; then
        exit_code=1
        if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
          err "Failed to process ${target}, continuing with next file"
        fi
      fi
      processed+=("${target}")
      ((file_count++))
    else
      err "Target not found: ${target}"
      exit_code=1
    fi
  done

  # Restore error handling
  set -e

  # Summary
  if [[ "${quiet}" -eq 0 && ${#processed[@]} -gt 0 ]]; then
    print_summary "${file_count}" "${exit_code}" "${verbose}" "${processed[@]}"
  fi

  return "${exit_code}"
}

main "$@"
