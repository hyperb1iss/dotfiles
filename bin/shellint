#!/usr/bin/env bash
#
# shellint - Shell script linter and formatter
# A powerful tool for checking and fixing shell scripts in your dotfiles
#
# Handles:
# 1. Linting with shellcheck
# 2. Formatting with shfmt
# 3. Auto-fixing shellcheck issues
#

set -eo pipefail

# ANSI color codes for beautiful output ðŸ’…
RESET="\033[0m"
BOLD="\033[1m"
RED="\033[38;5;197m"     # Hot pink for errors
ORANGE="\033[38;5;203m"  # For warnings
MAGENTA="\033[38;5;171m" # For info
PURPLE="\033[38;5;141m"  # For debug
BLUE="\033[38;5;75m"     # For verbose
CYAN="\033[38;5;123m"    # For success
PINK="\033[38;5;219m"    # For highlights
YELLOW="\033[38;5;227m"  # For caution

# Dependency check
check_deps() {
	local missing=0
	for cmd in shellcheck shfmt patch; do
		if ! command -v "${cmd}" &>/dev/null; then
			echo -e "${RED}${BOLD}Error:${RESET} ${cmd} is not installed"
			missing=1
		fi
	done

	if [[ ${missing} -eq 1 ]]; then
		echo -e "\n${YELLOW}Install missing dependencies:${RESET}"
		echo -e "  ${CYAN}â€¢ shellcheck:${RESET} https://github.com/koalaman/shellcheck#installing"
		echo -e "  ${CYAN}â€¢ shfmt:${RESET} https://github.com/mvdan/sh#shfmt"
		echo -e "  ${CYAN}â€¢ patch:${RESET} available in most package managers (apt, brew, etc.)"
		exit 1
	fi
}

# Print usage information
usage() {
	echo -e "${BOLD}${PURPLE}shellint${RESET} - Shell script linter and formatter ðŸ’–\n"
	echo -e "${BOLD}Usage:${RESET}"
	echo -e "  shellint [options] [file(s)/directory]\n"
	echo -e "${BOLD}Options:${RESET}"
	echo -e "  -c, --check         Check files without modifying them"
	echo -e "  -f, --fix           Auto-fix shellcheck issues when possible"
	echo -e "  -F, --format        Format files with shfmt"
	echo -e "  -a, --all           Run all checks and fixes (format + fix)"
	echo -e "  -r, --recursive     Recursively process directories"
	echo -e "  -q, --quiet         Minimal output"
	echo -e "  -v, --verbose       Verbose output"
	echo -e "  -e, --exclude=LIST  Exclude shellcheck codes (comma-separated)"
	echo -e "  -h, --help          Display this help message\n"
	echo -e "${BOLD}Examples:${RESET}"
	echo -e "  shellint --check sh/           # Check all .sh files in sh/ directory"
	echo -e "  shellint --fix sh/android.sh   # Fix shellcheck issues in android.sh"
	echo -e "  shellint --format --recursive  # Format all shell files recursively"
	echo -e "  shellint --all sh/             # Format and fix all scripts in sh/"
	echo -e "  shellint -e SC2086,SC2046 --fix # Fix issues excluding certain codes\n"
}

# Find shell scripts in a directory
find_scripts() {
	local dir="$1"
	local recursive="$2"

	# Use printf to ensure one item per line, avoid issues with different find implementations
	if [[ "${recursive}" -eq 1 ]]; then
		find "${dir}" -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.zsh" \) -not -path "*/\.*" -print 2>/dev/null || true
	else
		find "${dir}" -maxdepth 1 -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.zsh" \) -not -path "*/\.*" -print 2>/dev/null || true
	fi
}

# Check if file is a shell script based on content (for files without extensions)
is_shell_script() {
	local file="$1"

	# Check shebang
	head -n1 "${file}" | grep -q '^#!.*\(sh\|bash\|zsh\)'
}

# Run shellcheck on a file and report issues
run_shellcheck() {
	local file="$1"
	local exclude="$2"
	local quiet="$3"

	local exclude_arg=""
	if [[ -n "${exclude}" ]]; then
		exclude_arg="--exclude=${exclude}"
	fi

	if [[ "${quiet}" -eq 0 ]]; then
		echo -e "${MAGENTA}Checking${RESET} ${BOLD}${file}${RESET}..."
	fi

	# Find the project root (location of .shellcheckrc)
	local project_root
	project_root=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

	# Create a temporary copy of the file
	local tmp_file
	tmp_file=$(mktemp)
	cat "${file}" >"${tmp_file}" || {
		echo "Failed to create temporary file"
		return 1
	}

	# Define the config file path
	local config_file="${project_root}/.shellcheckrc"
	local config_arg=""
	if [[ -f "${config_file}" ]]; then
		config_arg="--rc=${config_file}"
	fi

	# Run shellcheck with project config
	local issues
	issues=$(shellcheck "${config_arg}" "${exclude_arg}" "${tmp_file}" 2>&1) || true

	# Clean up temp file
	rm -f "${tmp_file}"

	# Filter out the openBinaryFile error message if present
	issues=$(echo "${issues}" | grep -v "openBinaryFile: does not exist")

	if [[ -n "${issues}" ]]; then
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${ORANGE}Issues found in ${file}:${RESET}"
			echo "${issues}"
			echo
		fi
		return 1
	else
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${CYAN}âœ“ No issues in ${file}${RESET}"
		fi
		return 0
	fi
}

# Fix shellcheck issues using diff format
fix_shellcheck() {
	local file="$1"
	local exclude="$2"
	local quiet="$3"
	local verbose="$4"

	local exclude_arg=""
	if [[ -n "${exclude}" ]]; then
		exclude_arg="--exclude=${exclude}"
	fi

	if [[ "${quiet}" -eq 0 ]]; then
		echo -e "${PINK}Fixing${RESET} ${BOLD}${file}${RESET}..."
	fi

	# Find the project root (location of .shellcheckrc)
	local project_root
	project_root=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

	# Create a temporary copy of the file
	local tmp_file
	tmp_file=$(mktemp)
	cat "${file}" >"${tmp_file}" || {
		echo "Failed to create temporary file"
		return 1
	}

	# Define the config file path
	local config_file="${project_root}/.shellcheckrc"
	local config_arg=""
	if [[ -f "${config_file}" ]]; then
		config_arg="--rc=${config_file}"
	fi

	# Run shellcheck with project config
	local diff
	diff=$(shellcheck -f diff "${config_arg}" "${exclude_arg}" "${tmp_file}" 2>/dev/null)

	# Clean up temp file
	rm -f "${tmp_file}"

	if [[ -n "${diff}" && "${diff}" != "--- a/"* ]]; then
		#  The diff output doesn't look like a proper patch
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${YELLOW}No auto-fixable issues in ${file}${RESET}"
		fi
		return 0
	fi

	if [[ -n "${diff}" ]]; then
		if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
			echo -e "${BLUE}Applying fixes to ${file}:${RESET}"
			echo "${diff}"
		fi

		# Create a temporary directory for patching
		local tmp_dir
		tmp_dir=$(mktemp -d)

		# Create subdirectory structure
		mkdir -p "${tmp_dir}/a" "${tmp_dir}/b"

		# Copy the file to both directories
		cp "${file}" "${tmp_dir}/a/"
		cp "${file}" "${tmp_dir}/b/"

		# Modify the diff to use our temporary paths
		local file_name
		file_name=$(basename "${file}")
		local modified_diff
		modified_diff=$(echo "${diff}" | sed "s|--- a/.*|--- a/${file_name}|" | sed "s|+++ b/.*|+++ b/${file_name}|")

		# Apply the diff in the temporary directory
		echo "${modified_diff}" | (cd "${tmp_dir}" && patch -p1 -s)

		# Copy the patched file back
		cp "${tmp_dir}/b/${file_name}" "${file}"

		# Clean up
		rm -rf "${tmp_dir}"

		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${CYAN}âœ“ Fixed issues in ${file}${RESET}"
		fi
		return 0
	else
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${CYAN}âœ“ No issues to fix in ${file}${RESET}"
		fi
		return 0
	fi
}

# Format script with shfmt
format_script() {
	local file="$1"
	local quiet="$2"
	local verbose="$3"

	if [[ "${quiet}" -eq 0 ]]; then
		echo -e "${MAGENTA}Formatting${RESET} ${BOLD}${file}${RESET}..."
	fi

	# Convert to absolute path if not already
	local abs_file
	abs_file=$(readlink -f "${file}" 2>/dev/null || realpath "${file}" 2>/dev/null || echo "${file}")

	# Check if formatting is needed first
	local needs_formatting
	needs_formatting=$(shfmt -l -i 0 -bn -ci -sr "${abs_file}" 2>/dev/null)

	if [[ -n "${needs_formatting}" ]]; then
		if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
			local diff
			diff=$(shfmt -d -i 0 -bn -ci -sr "${abs_file}" 2>/dev/null)
			echo -e "${BLUE}Formatting changes for ${file}:${RESET}"
			echo "${diff}"
		fi

		# Apply formatting
		shfmt -w -i 0 -bn -ci -sr "${abs_file}" 2>/dev/null

		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${CYAN}âœ“ Formatted ${file}${RESET}"
		fi
	else
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${CYAN}âœ“ ${file} already properly formatted${RESET}"
		fi
	fi
}

# Process a single file
process_file() {
	local file="$1"
	local check="$2"
	local fix="$3"
	local format="$4"
	local exclude="$5"
	local quiet="$6"
	local verbose="$7"

	# Skip non-existent files
	if [[ ! -f "${file}" ]]; then
		if [[ "${quiet}" -eq 0 ]]; then
			echo -e "${RED}File not found: ${file}${RESET}"
		fi
		return 1
	fi

	# Check if it's a shell script based on extension
	if [[ ! "${file}" =~ \.(sh|bash|zsh)$ ]]; then
		# For files without extension, check content
		local is_shell=0
		is_shell=$(
			is_shell_script "${file}"
			echo $?
		)
		if [[ "${is_shell}" -ne 0 ]]; then
			if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
				echo -e "${YELLOW}Skipping non-shell file: ${file}${RESET}"
			fi
			return 0
		fi
	fi

	local status=0

	# Format file if needed
	if [[ "${format}" -eq 1 ]]; then
		format_script "${file}" "${quiet}" "${verbose}"
	fi

	# Fix shellcheck issues
	if [[ "${fix}" -eq 1 ]]; then
		fix_shellcheck "${file}" "${exclude}" "${quiet}" "${verbose}"
	fi

	# Check for issues
	if [[ "${check}" -eq 1 ]]; then
		# Call run_shellcheck separately from the condition to avoid SC2310
		run_shellcheck "${file}" "${exclude}" "${quiet}"
		local shellcheck_result=$?
		if [[ "${shellcheck_result}" -ne 0 ]]; then
			status=1
		fi
	fi

	return "${status}"
}

# Main function
main() {
	check_deps

	local check=1 # Default to check mode
	local fix=0
	local format=0
	local recursive=0
	local quiet=0
	local verbose=0
	local exclude=""
	local exit_code=0
	local targets=()

	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-c | --check)
			check=1
			shift
			;;
		-f | --fix)
			fix=1
			shift
			;;
		-F | --format)
			format=1
			shift
			;;
		-a | --all)
			check=1
			fix=1
			format=1
			shift
			;;
		-r | --recursive)
			recursive=1
			shift
			;;
		-q | --quiet)
			quiet=1
			shift
			;;
		-v | --verbose)
			verbose=1
			shift
			;;
		-e=* | --exclude=*)
			exclude="${1#*=}"
			shift
			;;
		-e | --exclude)
			exclude="$2"
			shift 2
			;;
		-h | --help)
			usage
			exit 0
			;;
		-*)
			echo -e "${RED}Unknown option: $1${RESET}"
			usage
			exit 1
			;;
		*)
			targets+=("$1")
			shift
			;;
		esac
	done

	# If no targets specified, use current directory
	if [[ ${#targets[@]} -eq 0 ]]; then
		targets=(".")
	fi

	# Debug: Show targets
	if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
		echo -e "${BLUE}Processing targets:${RESET}"
		for target in "${targets[@]}"; do
			echo -e "  - ${target}"
		done
	fi

	# Process all targets
	local file_count=0
	local processed=()

	# Don't fail fast, process all files
	set +e

	for target in "${targets[@]}"; do
		if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
			echo -e "${BLUE}Processing target: ${target}${RESET}"
		fi

		if [[ -d "${target}" ]]; then
			# Process directory
			local scripts
			if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
				echo -e "${BLUE}Finding scripts in directory: ${target} (recursive=${recursive})${RESET}"
			fi

			scripts=$(find_scripts "${target}" "${recursive}")

			if [[ -z "${scripts}" ]]; then
				if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
					echo -e "${YELLOW}No scripts found in ${target}${RESET}"
				fi
				continue
			fi

			if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
				echo -e "${BLUE}Found scripts:${RESET}"
				while IFS= read -r script; do
					echo "  - ${script}"
				done <<<"${scripts}"
			fi

			# Process each script found
			while IFS= read -r script; do
				if [[ -n "${script}" ]]; then
					if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
						echo -e "${BLUE}Processing script: ${script}${RESET}"
					fi

					# Call process_file separately from the condition to avoid SC2310
					process_file "${script}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}"
					local process_result=$?
					if [[ "${process_result}" -ne 0 ]]; then
						exit_code=1
						if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
							echo -e "${RED}Failed to process ${script}, continuing with next file${RESET}"
						fi
					fi
					processed+=("${script}")
					((file_count++))
				fi
			done < <(echo "${scripts}")
		elif [[ -f "${target}" ]]; then
			# Process single file
			if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
				echo -e "${BLUE}Processing file: ${target}${RESET}"
			fi

			# Call process_file separately from the condition to avoid SC2310
			process_file "${target}" "${check}" "${fix}" "${format}" "${exclude}" "${quiet}" "${verbose}"
			local process_result=$?
			if [[ "${process_result}" -ne 0 ]]; then
				exit_code=1
				if [[ "${verbose}" -eq 1 && "${quiet}" -eq 0 ]]; then
					echo -e "${RED}Failed to process ${target}, continuing with next file${RESET}"
				fi
			fi
			processed+=("${target}")
			((file_count++))
		else
			echo -e "${RED}Target not found: ${target}${RESET}"
			exit_code=1
		fi
	done

	# Restore error handling
	set -e

	# Summary
	if [[ "${quiet}" -eq 0 && ${#processed[@]} -gt 0 ]]; then
		echo
		echo -e "${BOLD}${CYAN}Summary:${RESET}"
		echo -e "${MAGENTA}Processed ${BOLD}${file_count}${RESET}${MAGENTA} files${RESET}"

		if [[ "${verbose}" -eq 1 ]]; then
			echo -e "${BLUE}Files processed:${RESET}"
			for file in "${processed[@]}"; do
				echo -e "  - ${file}"
			done
		fi

		if [[ "${exit_code}" -eq 0 ]]; then
			echo -e "${BOLD}${CYAN}All checks passed! ðŸ’…${RESET}"
		else
			echo -e "${BOLD}${ORANGE}Some checks failed. Review the output above.${RESET}"
		fi
	fi

	return "${exit_code}"
}

main "$@"
